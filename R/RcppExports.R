# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @importFrom RcppParallel RcppParallelLibs
NULL

#' A direct sampler for GWishart distributed random variables.  
#'
#'\loadmathjax This function draws a random matrices, distributed according to the GWishart distribution with Shape parameter \code{b} and Inverse-Scale matrix \code{D}, 
#' whose structure is constrained by graph \code{G}. The GWishart distribution, taking into account a Shape-Inverse Scale parametrization, is the following:
#' \mjsdeqn{p(K~|~ G, b,D) = I_{G}\left(b, D\right)^{-1} |K|^{\frac{b - 2}{2}} \exp\left( - \frac{1}{2}tr\left(K D\right)\right)}
#' It works with both decomposable and non decomposable graphs. In particular it is possible to provide a graph in block form. 
#' @param G matrix representing the desired graph. It has to be a \mjseqn{p \times p} matrix if the graph is in block form, i.e if groups is non null, 
#' otherwise it has to be coherent with the number of groups. Only the upper triangular part is needed.
#' @param b GWishart Shape parameter. It has to be larger than 2 in order to have a well defined distribution.
#' @param D It is a \mjseqn{p \times p} matrix. Different parametrizations are possible, they are handled by the \code{form} input parameter.
#' @param norm String to choose the matrix norm with respect to whom convergence takes place. The available choices are \code{"Mean"}, \code{"Inf"}, \code{"One"} and \code{"Squared"}. 
#' \code{"Mean"} is the default value and it is also used when a wrong input is provided.
#' @param form String, states what type of parameter is represented by \code{D}. Possible values are \code{"Scale"} for Scale parametrization, 
#' \code{"InvScale"} for Inverse-Scale parametrization or \code{"CholLower_InvScale"} and \code{"CholUpper_InvScale"} to pass directly the Cholesky factorization of the Inverse-Scale matrix.
#' Usually GWishart distributions are parametrized with respect to the Inverse Scale matrix. However the first step of the sampling requires the Scale matrix parameter or, even better, its Cholesky decomposition. 
#' This functions leaves a lot of freedom to the user so that the most efficient available parametrization can be used.
#' @param groups List representing the groups of the block form. Numerations starts from 0 and vertrices has to be contiguous from group to group, 
#' i.e ((0,1,2),(3,4)) is fine but ((1,2,3), (4,5)) and ((1,3,5), (2,4)) are not. Leave NULL if the graph is not in block form.
#' @param check_structure bool, if \code{TRUE} it is checked if the sampled matrix actually respects the structure of the graph.
#' @param max_iter unsigned int, the maximum number of iteration.
#' @param threshold_check the accurancy for checking if the sampled matrix respects the structure of the graph.
#' @param threshold_conv  the threshold value for the convergence of sampling algorithm from GWishart. Algorithm stops if the difference between two subsequent iterations is less than \code{threshold_conv}.
#' @param seed integer, seeding value. Set 0 for random seed.
#' @return A list is returned, it is composed of: \code{Matrix} that contains the random matrix just sampled, \code{Converged} that is a boolean that states if the algorithm reached convergence or not, 
#' the number performed iterations can be found in \code{iterations} and, if requested in the \code{check_structure} parameters, an additional boolean called \code{CheckStructure} is returned.
#' @export
rGwish <- function(G, b, D, norm = "Mean", form = "InvScale", groups = NULL, check_structure = FALSE, max_iter = 500L, threshold_check = 0.00001, threshold_conv = 0.00000001, seed = 0L) {
    .Call(`_BGSL_rGwish`, G, b, D, norm, form, groups, check_structure, max_iter, threshold_check, threshold_conv, seed)
}

#' Normalizing constant for GWishart distribution
#'
#' \loadmathjax This function computes the logarithm of the normalizing constant of GWishart distribution. Its distribution, taking into account a Shape-Inverse Scale parametrization, is the following:
#' \mjsdeqn{p\left(K~|~ G, b,D \right) = I_{G}\left(b, D\right)^{-1} |K|^{\frac{b - 2}{2}} \exp\left( - \frac{1}{2}tr\left(K D\right)\right)}
#' The Monte Carlo method, developed by Atay-Kayis and Massam (2005), is implemented. It works with both decomposable and non decomposable graphs. 
#' In particular it is possible to provide a graph in block form. 
#' @param G matrix representing the desired graph. It has to be a \mjseqn{p \times p} matrix if the graph is in block form, i.e if groups is non null, 
#' otherwise it has to be coherent with the number of groups. Only the upper triangular part is needed.
#' @param b GWishart Shape parameter. It has to be larger than 2 in order to have a well defined distribution.
#' @param D GWishart Inverse-Scale matrix. It has to be of size \mjseqn{p \times p}, symmetric and positive definite. 
#' @param MCiteration the number of iterations for the Monte Carlo approximation. 
#' @param groups a Rcpp list representing the groups of the block form. Numerations starts from 0 and vertrices has to be contiguous from group to group, 
#' i.e ((0,1,2),(3,4)) is fine but ((1,2,3), (4,5)) and ((1,3,5), (2,4)) are not. Leave \code{NULL} if the graph is not in block form.
#' @param seed integer, seeding value. Set 0 for random seed.
#' @return log of the normalizing constant of GWishart distribution.
#' @export
log_Gconstant <- function(G, b, D, MCiteration = 500L, groups = NULL, seed = 0L) {
    .Call(`_BGSL_log_Gconstant`, G, b, D, MCiteration, groups, seed)
}

#' Generate a random graph
#'
#' \loadmathjax This function genrates random graphs both in \code{"Complete"} or \code{"Block"} form. 
#' @param p integer, the dimension of the underlying graph. It has to be provided even if \code{form} is \code{"Block"}.
#' @param n_groups iinteger, number of desired groups. Not used if form is \code{"Complete"} or if the groups are directly insered in \code{groups} parameter.
#' @param form string that may take as values only \code{"Complete"} of \code{"Block"} . It states if the algorithm has to run with \code{"Block"} or \code{"Complete"} graphs.
#' @param groups List representing the groups of the block form. Numerations starts from 0 and vertrices has to be contiguous from group to group, 
#' i.e ((0,1,2),(3,4)) is fine but ((1,2,3), (4,5)) and ((1,3,5), (2,4)) are not. Leave \code{NULL} if the graph is not in block form.
#' @param sparsity desired sparsity in the graph. It has to be in the range \mjseqn{(0,1)}. 
#' @param seed integer, seeding value. Set 0 for random seed.
#' @return A list is returned, it contains the randomly generated graph in \code{G} and its complete form in \code{G_Complete}. Those two coincide if \code{form} is \code{"Complete"}.
#' @export
Create_RandomGraph <- function(p, n_groups = 0L, form = "Complete", groups = NULL, sparsity = 0.5, seed = 0L) {
    .Call(`_BGSL_Create_RandomGraph`, p, n_groups, form, groups, sparsity, seed)
}

#' Sampler for Multivariate Normal random variables
#'
#' \loadmathjax This function draws random samples from Multivariate Gaussian distribution. It allows for both covariance and precision parametrization.
#' It is also possible to pass directly the Cholesky decomposition if it is available before the call.
#' @param mean vector of size \code{p} representig the mean of the Gaussian distribution.
#' @param Mat matrix of size \mjseqn{p \times p} representinf the covariance or the precision matrix or their Cholesky decompositions.
#' @param isPrec boolean, set \code{TRUE} if Mat parameter is a precision, \code{FALSE} if it is a covariance.
#' @param isChol boolean, set \code{TRUE} if Mat parameter is a triangular matrix representig the Cholesky decomposition of the precision or covariance matrix.
#' @param isUpper boolean, used only if \code{isChol} is \code{TRUE}. Set \code{TRUE} if Mat is upper triangular, \code{FALSE} if lower.
#' @param seed integer, seeding value. Set 0 for random seed.
#' @return It returns a \mjseqn{p}-dimensional vector with the sampled values.
#' @export
rmvnormal <- function(mean, Mat, isPrec = FALSE, isChol = FALSE, isUpper = FALSE, seed = 0L) {
    .Call(`_BGSL_rmvnormal`, mean, Mat, isPrec, isChol, isUpper, seed)
}

#' Sampler for Wishart random variables
#'
#' \loadmathjax This function draws random samples from Wishart distribution. We use a Shape-Inverse Scale parametrization, the corresponding density is reported below
#' \mjsdeqn{ f(X) = \frac{|X|^{(b-2)/2}~~\exp\left( - \frac{1}{2}tr\left(X~D\right)\right)}{2^{p(b+p-1)/2}~|D^{-1}|^{(b+p-1)/2}~\Gamma_{p}((b+p-1)/2)}}
#' It is also possible to pass directly the Cholesky decomposition of the Inverse Scale matrix if it is available before the call.
#' @param b it is Shape parameter. 
#' @param D Inverse-Scale matrix of size \mjseqn{p \times p}. It may represent its Cholesky decomposition.
#' @param isChol boolean, set \code{TRUE} if D parameter is a triangular matrix representig the Cholesky decomposition of the precision or covariance
#' @param isUpper boolean, used only if isChol is \code{TRUE}. Set \code{TRUE} if D is upper triangular, \code{FALSE} if lower.
#' @param seed integer, seeding value. Set 0 for random seed.
#' @return It returns the \mjseqn{p \times p} sampled matrix.
#' @export
rwishart <- function(b, D, isChol = FALSE, isUpper = FALSE, seed = 0L) {
    .Call(`_BGSL_rwishart`, b, D, isChol, isUpper, seed)
}

#' Sampler for Normal distribution
#' 
#' This function draw a sample from the Gaussian distribution.
#' @param mean the mean value.
#' @param sd the standard deviation.
#' @param seed integer, seeding value. Set 0 for random seed.
#'
#' @return A single drawn values from N(mean,sd*sd).
#' @export
rnormal <- function(mean = 0.0, sd = 1.0, seed = 0L) {
    .Call(`_BGSL_rnormal`, mean, sd, seed)
}

#' Generate Bspine basis 
#' 
#' \loadmathjax This function creates a truncated Bspline basis in the interval \mjseqn{\[range(1),range(2)\]} and evaluate them over a grid of points.
#' It assumes uniformly spaced breakpoints and constructs the corresponding knot vector using a number of breaks equal to \mjseqn{n\_basis + 2 - order}.
#' @param n_basis the number of basis functions.
#' @param range vector of two elements containing first the lower and then the upper bound of the interval.
#' @param n_points number of grid points where the basis has to be evaluated. It is not used if the points are directly passed in the \code{grid_points} parameter.
#' @param grid_points vector of points where the basis has to be evaluated. If defaulted, then \code{n_points} are uniformly generated in the interval.
#' @param order integer, order of the Bsplines. Set four for cubic splines.
#' @return a list containing a matrix of dimension \mjseqn{n\_points \times n\_basis} such that \code{r}-th rows contains all the spline computed in the \code{r}-th point of the grid and \code{j}-th column
#' contains the \code{j}-th spline evaluated in all grid points. It also returns a vector of size \mjseqn{n\_basis + 2 - order} containing the internal knots used to create the spline.
#' @export
Generate_Basis <- function(n_basis, range, n_points = 0L, grid_points = as.numeric( c(0)), order = 3L) {
    .Call(`_BGSL_Generate_Basis`, n_basis, range, n_points, grid_points, order)
}

#' Generate Bspine basis and its derivatives
#'
#' \loadmathjax This function creates a truncated Bspline basis in the interval \mjseqn{\[range(1),range(2)\]} and evaluate them over a grid of points up to derivative of order \code{nderiv}.
#' For convention, derivatives of order 0 are the splines themselves. This implimes that the first returned element is always equal to the output of the function \code{\link{Generate_Basis}}.
#' @param n_basis the number of basis functions.
#' @param nderiv number of derivates that have to be computed. It can also be 0.
#' @param range vector of two elements containing first the lower and then the upper bound of the interval.
#' @param n_points number of grid points where the basis has to be evaluated. It is not used if the points are directly passed in the \code{grid_points} parameter.
#' @param grid_points vector of points where the basis has to be evaluated. If defaulted, then \code{n_points} are uniformly generated in the interval.
#' @param order integer, order of the Bsplines. Set four for cubic splines.
#' @return a list of length nderiv+1 such that each element is a \mjseqn{n\_points \times n\_basis} matrix representing the evaluation of 
#' the \code{k}-th derivative of all the splines in all the grid points. 
#' @export
Generate_Basis_derivatives <- function(n_basis, nderiv, range, n_points = 0L, grid_points = as.numeric( c(0)), order = 3L) {
    .Call(`_BGSL_Generate_Basis_derivatives`, n_basis, nderiv, range, n_points, grid_points, order)
}

#' Read information from file
#'
#' \loadmathjax Read from \code{file_name} some information that are needed to extract data from it. 
#' @param file_name, string with the name of the file to be open. It has to include the extension, usually \code{.h5}.
#' @return It returns a list containing \code{p}, the dimension of the graph, \code{n} the number of observed data, \code{stored_iter} the number of saved iterations for the regression parameters,
#' \code{stored_iterG} the number of saved iterations for the graphical related quantities, i.e the graph and the precision matrix. Finally, \code{sampler} recalls what type of sampler was used. 
#' Possibilities are \code{"GGMsampler"}, \code{"FGMsampler"}, \code{"FLMsampler_diagonal"} or \code{"FLMsampler_fixed"}.
#' @export
Read_InfoFile <- function(file_name) {
    .Call(`_BGSL_Read_InfoFile`, file_name)
}

#' Compute quantiles of sampled values
#'
#' \loadmathjax This function reads the sampled values saved in a binary file and computes the quantiles of the desired level.
#' @param file_name, string with the name of the file to be open. It has to include the extension, usually \code{.h5}.
#' @param Beta boolean, set \code{TRUE} to compute the quantiles for all \code{p*n} \mjseqn{\beta} coefficients. It may require long time.
#' @param Mu boolean, set \code{TRUE} to compute the quantiles for all \mjseqn{p} parameters. 
#' @param TauEps boolean, set \code{TRUE} to compute the quantiles of \mjseqn{\tau_{\epsilon}} parameter.
#' @param Precision boolean, set \code{TRUE} to compute the mean for all the elements of the precision matrix 
#' or the \mjseqn{\tau_{j}} coefficients if the file contains the output of a \code{\link{FLM_sampling}}, diagonal version.
#' @param lower_qtl the level of the first desired quantile.
#' @param upper_qtl the level of the second desired quantile.
#'
#' @return It returns a list containig the upper and lower quantiles of the requested quantities.
#' @export
Compute_Quantiles <- function(file_name, Beta = FALSE, Mu = FALSE, TauEps = FALSE, Precision = FALSE, lower_qtl = 0.05, upper_qtl = 0.95) {
    .Call(`_BGSL_Compute_Quantiles`, file_name, Beta, Mu, TauEps, Precision, lower_qtl, upper_qtl)
}

#' Compute Posterior means of sampled values
#'
#' \loadmathjax This function reads the sampled values saved in a binary file and computes the mean of the requested quantities.
#' @param file_name, string with the name of the file to be open. It has to include the extension, usually \code{.h5}.
#' @param Beta boolean, set \code{TRUE} to compute the mean for all \code{p*n} \mjseqn{\beta} coefficients. It may require long time.
#' @param Mu boolean, set \code{TRUE} to compute the mean for all \mjseqn{p} parameters. 
#' @param TauEps boolean, set \code{TRUE} to compute the mean of \mjseqn{\tau_{\epsilon}} parameter.
#' @param Precision boolean, set \code{TRUE} to compute the mean for all the elements of the precision matrix 
#' or the \mjseqn{\tau_{j}} coefficients if the file contains the output of a \code{\link{FLM_sampling}}, diagonal version.
#' @return It returns a list containig the mean of the requested quantities.
#' @export
Compute_PosteriorMeans <- function(file_name, Beta = FALSE, Mu = FALSE, TauEps = FALSE, Precision = FALSE) {
    .Call(`_BGSL_Compute_PosteriorMeans`, file_name, Beta, Mu, TauEps, Precision)
}

#' Read chain from file
#'
#' \loadmathjax This function read from a binary file the sampled chain for the \code{index1}-th component of variable specified in \code{variable}. The chain is then saved in memory to make it available for further analysis.
#' Both \code{index1} and \code{index2} start counting from 1, the first element is obtained by settin \code{index1} equal to 1, not 0.
#' Only \code{"Beta"} coefficients require the usage of \code{index2}. This function allows to extract only one chain at the time. The idea of writing the sampled values on a file is indeed to
#' avoid to fill the memory. This function has to carefully used.
#' @param file_name, string with the name of the file to be open. It has to include the extension, usually \code{.h5}.
#' @param variable string, the name of the dataset to be read from the file. Only possibilities are \code{"Beta"}, \code{"Mu"}, \code{"Precision"} and \code{"TauEps"}.
#' @param index1 integer, the index of the element whose chain has to read from the file. The first elements corresponds to \code{index1} equal to 1. 
#' If \code{variable} is equal to \code{"Precision"} some care is required. If the file represents the output of \code{GGM}, \code{FGM} of \code{FLM} with fixed graph, the sampled precision matrices 
#' are of size \mjseqn{p \times p} stored row by row. This means that the second diagonal elements corresponds to \code{index1} equal to \mjseqn{p+1}. 
#' Moreover, in this case set \code{prec_elem} parameter equal to \mjseqn{\frac{p(p+1)}{2}}. 
#' Instead, for outputs coming from \code{FLM} sampler with diagonal graph, only the diagonal of the precision matrix is saved. If so, \code{index1} ranges from 1 up to \mjseqn{p}. Moreover, set \code{prec_ele} eqaul to \mjseqn{p}.
#' If \code{variable} is equal to \code{"Beta"}, this index ranges for 1 up to \mjseqn{p}, it represents the spine coefficinet.
#' @param index2 integer, to be used only if \code{variable} is equal to \code{"Beta"}. It ranges from 1 up to \mjseqn{n}. In this case, the chain for the spline_index-th coefficients of the curve_index-th curve is read.
#'
#' @return It returns a numeric vector all the sampled values of the required element.
#' @export
Extract_Chain <- function(file_name, variable, index1 = 1L, index2 = 1L) {
    .Call(`_BGSL_Extract_Chain`, file_name, variable, index1, index2)
}

#' Read the sampled Graph saved on file
#'
#' \loadmathjax This function reads the sampled graphs that are saved on a binary file and performs a summary of all visited graphs.
#' @param file_name, string with the name of the file to be open. It has to include the extension, usually \code{.h5}.
#' @param groups List representing the groups of the block form. Numerations starts from 0 and vertrices has to be contiguous from group to group, 
#' i.e ((0,1,2),(3,4)) is fine but ((1,2,3), (4,5)) and ((1,3,5), (2,4)) are not. Leave \code{NULL} if the graph is not in block form.
#'
#' @return It returns a list composed of: \code{plinks} that contains the posterior probability of inclusion of each possible link. \code{AcceptedMoves} contains the number of
#' Metropolis-Hastings moves that were accepted in the sampling, \code{VisitedGraphs} the number of graph that were visited at least once, \code{TracePlot_Gsize} is a vector 
#' such that each element is equal to the size of the visited graph in that particular iteration and finally \code{SampledGraphs} is a list containing all the visited graphs and their absolute frequence of visit.
#' To save memory, the graphs are represented only by the upper triangular part, stored row-wise. 
#' @export
Summary_Graph <- function(file_name, groups = NULL) {
    .Call(`_BGSL_Summary_Graph`, file_name, groups)
}

SimulateData_GGM_c <- function(p, n, n_groups, form, graph, adj_mat, seed, mean_null, sparsity, groups = NULL) {
    .Call(`_BGSL_SimulateData_GGM_c`, p, n, n_groups, form, graph, adj_mat, seed, mean_null, sparsity, groups)
}

#' Create Groups
#' 
#' \loadmathjax This function creates a list with the groups. If possible, groups of equal size are created. The goal of this function is to fix a precise notation that will be used in all the code.
#' It is indeed recommended to use this function to create them as they need to follow a precise notation.
#' @param p integer, the dimension of the underlying graph.
#' @param n_groups number of desired groups. Has to be greater than \code{p}.
#' @return list representing the groups of the block form.
#' @export
CreateGroups <- function(p, n_groups) {
    .Call(`_BGSL_CreateGroups`, p, n_groups)
}

GGM_sampling_c <- function(data, p, n, niter, burnin, thin, file_name, D, b, G0, K0, MCprior = 100L, MCpost = 100L, threshold = 0.00000001, form = "Complete", prior = "Uniform", algo = "MH", groups = NULL, seed = 0L, Gprior = 0.5, sigmaG = 0.1, paddrm = 0.5, print_info = TRUE) {
    .Call(`_BGSL_GGM_sampling_c`, data, p, n, niter, burnin, thin, file_name, D, b, G0, K0, MCprior, MCpost, threshold, form, prior, algo, groups, seed, Gprior, sigmaG, paddrm, print_info)
}

FLM_sampling_c <- function(data_list, niter, burnin, thin, BaseMat, grid_list, G, Beta0, mu0, tau_eps0, tauK0, K0, a_tau_eps, b_tau_eps, sigmamu, aTauK, bTauK, bK, DK, file_name, diagonal_graph = TRUE, threshold_GWish = 0.00000001, seed = 0L, print_info = TRUE) {
    .Call(`_BGSL_FLM_sampling_c`, data_list, niter, burnin, thin, BaseMat, grid_list, G, Beta0, mu0, tau_eps0, tauK0, K0, a_tau_eps, b_tau_eps, sigmamu, aTauK, bTauK, bK, DK, file_name, diagonal_graph, threshold_GWish, seed, print_info)
}

FGM_sampling_c <- function(data, niter, burnin, thin, thinG, BaseMat, file_name, Beta0, mu0, tau_eps0, G0, K0, a_tau_eps, b_tau_eps, sigmamu, bK, DK, sigmaG, paddrm, Gprior, MCprior, MCpost, threshold, form = "Complete", prior = "Uniform", algo = "MH", groups = NULL, seed = 0L, print_info = TRUE) {
    .Call(`_BGSL_FGM_sampling_c`, data, niter, burnin, thin, thinG, BaseMat, file_name, Beta0, mu0, tau_eps0, G0, K0, a_tau_eps, b_tau_eps, sigmamu, bK, DK, sigmaG, paddrm, Gprior, MCprior, MCpost, threshold, form, prior, algo, groups, seed, print_info)
}

Read_InfoFile_old <- function(file_name) {
    .Call(`_BGSL_Read_InfoFile_old`, file_name)
}

Compute_Quantiles_old <- function(file_name, p, n, stored_iterG = 0L, stored_iter = 0L, Beta = FALSE, Mu = FALSE, TauEps = FALSE, Precision = FALSE, prec_elem = 0L, lower_qtl = 0.05, upper_qtl = 0.95) {
    .Call(`_BGSL_Compute_Quantiles_old`, file_name, p, n, stored_iterG, stored_iter, Beta, Mu, TauEps, Precision, prec_elem, lower_qtl, upper_qtl)
}

Extract_Chain_old <- function(file_name, variable, stored_iter, p, n = 0L, index1 = 1L, index2 = 1L, prec_elem = 0L) {
    .Call(`_BGSL_Extract_Chain_old`, file_name, variable, stored_iter, p, n, index1, index2, prec_elem)
}

Compute_PosteriorMeans_old <- function(file_name, p, n, stored_iterG = 0L, stored_iter = 0L, Beta = FALSE, Mu = FALSE, TauEps = FALSE, Precision = FALSE, prec_elem = 0L) {
    .Call(`_BGSL_Compute_PosteriorMeans_old`, file_name, p, n, stored_iterG, stored_iter, Beta, Mu, TauEps, Precision, prec_elem)
}

Summary_Graph_old <- function(file_name, stored_iterG, p, groups = NULL) {
    .Call(`_BGSL_Summary_Graph_old`, file_name, stored_iterG, p, groups)
}

