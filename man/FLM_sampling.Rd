% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BGSL_export.R
\name{FLM_sampling}
\alias{FLM_sampling}
\title{Functional Linear model for smoothing}
\usage{
FLM_sampling(
  p,
  data,
  niter = 1e+05,
  burnin = niter/2,
  thin = 1,
  diagonal_graph = T,
  G = NULL,
  Param = NULL,
  HyParam = NULL,
  Init = NULL,
  print_info = TRUE,
  seed = 0,
  file_name = "FLMresults"
)
}
\arguments{
\item{p}{number of basis functions.}

\item{data}{matrix of dimension \mjseqn{n\_curves \times n\_grid\_points} containing the evaluation of \code{n} functional data over a grid of \code{n_grid_points} nodes.}

\item{niter}{the number of total iterations to be performed in the sampling. The number of saved iteration will be \mjseqn{(niter - burnin)/thin}.}

\item{burnin}{the number of discarded iterations.}

\item{thin}{the thining value, it means that only one out of \code{thin} itarations is saved.}

\item{diagonal_graph}{boolean, set true if the graph has to be diagonal. Set false otherwise and pass as input the desired graph through the \code{G} parameter.}

\item{G}{matrix of size \mjseqn{p \times p} representing the graphical part of the model that would remain fixed through out the sampling. Needed only if \code{diagonal_graph} is set to \code{FALSE}.}

\item{Param}{list containing parameters needed by the sampler. It has to follow the same notation of the one generated by \code{\link{sampler_parameters}} function.
It is indeed recommended to build it through that particular function. It is important to remember that \code{BaseMat} field is needed and cannot be defaulted. Use \code{\link{Generate_Basis}} to create it.
It has to be a matrix of dimension \mjseqn{n\_grid\_points \times p} containing the evalutation of \code{p} Bspline basis over a grid of \code{n_grid_points} nodes.}

\item{HyParam}{list containing hyperparameters needed by the sampler. It has to follow the same notation of the one generated by \code{\link{LM_hyperparameters}} function. It is indeed recommended to build it through that particular function.}

\item{Init}{list containig initial values for Markov chain. It has to follow the same notation of the one generated by \code{\link{LM_init}} function. It is indeed recommended to build it through that particular function.}

\item{print_info}{boolean, set \code{TRUE} to display the progress bar.}

\item{seed}{integer, seeding value. Set 0 for random seed.}

\item{file_name}{string, the name of the binary \code{".h5"} file where the sampled values are wittern}
}
\value{
It returns a list with the posterior mean of the sampled values. If \code{diagonal_graph} is \code{TRUE}, \code{p} \mjseqn{\tau_{j}} coefficients are returned, if it is \code{FALSE}
the full estimated precision matrix is returned. A binary \code{".h5"} file named \code{file_name} is also generated, it contains all the sampled values.
}
\description{
\loadmathjax This function performs a linear regression for functional data.
It is not a graphical model, the graph has to be fixed. It is possible to fix both a diagonal graph or a generic graph. In the first case, the model one sample from is the following,
\mjtdeqn{$$\begin{eqnarray*}Y_{i}~|~\beta_{i},~\tau_{\epsilon} ~\sim~&N_{r}\left(\Phi\beta_{i},\tau_{\epsilon}I_{r}\right), \forall i = 1:n \cr \beta_{1},\dots,\beta_{n}~|~\mu,~K~\sim~&N_{p}\left(\mu,K\right) K=diag\left(\tau_{1},\dots,\tau_{p}\right) \cr \mu~\sim~&N_{p}\left(0,\sigma_{\mu}I_{p}\right) \cr \tau_{\epsilon} ~\sim~& Gamma\left(a,b\right) \cr \tau_{j} ~\sim~& Gamma\left(\frac{a}{2},\frac{b}{2}\right) \forall j = 1:p \end{eqnarray*}$$}{\begin{eqnarray*}Y_{i}~|~\beta_{i},~\tau_{\epsilon} &~\sim~&N_{r}\left(\Phi\beta_{i},\tau_{\epsilon}I_{r}\right), &\forall i &= 1:n \cr \beta_{1},\dots,\beta_{n}~|~\mu,~K&~\sim~&N_{p}\left(\mu,K\right) &K&=diag\left(\tau_{1},\dots,\tau_{p}\right) \cr \mu&~\sim~&N_{p}\left(0,\sigma_{\mu}I_{p}\right) \cr \tau_{\epsilon} &~\sim~& Gamma\left(a,b\right) \cr \tau_{j} &~\sim~& Gamma\left(\frac{a}{2},\frac{b}{2}\right) &\forall j &= 1:p \end{eqnarray*}}{\begin{eqnarray*}Y_{i}~|~\beta_{i},~\tau_{\epsilon} &~\sim~&N_{r}\left(\Phi\beta_{i},\tau_{\epsilon}I_{r}\right), &\forall i &= 1:n \cr \beta_{1},\dots,\beta_{n}~|~\mu,~K&~\sim~&N_{p}\left(\mu,K\right) &K&=diag\left(\tau_{1},\dots,\tau_{p}\right) \cr \mu&~\sim~&N_{p}\left(0,\sigma_{\mu}I_{p}\right) \cr \tau_{\epsilon} &~\sim~& Gamma\left(a,b\right) \cr \tau_{j} &~\sim~& Gamma\left(\frac{a}{2},\frac{b}{2}\right) &\forall j &= 1:p \end{eqnarray*}}
Otherwise it is possible to keep the graph fixed even if it is not diagonal. In this case the precision matrix is modeled a priori as a \code{GWishart}. The resulting model is the following,
\mjtdeqn{$$\begin{eqnarray*}Y_{i}~|~\beta_{i},~\tau_{\epsilon} ~\sim~&N_{r}\left(\Phi\beta_{i},\tau_{\epsilon}I_{r}\right), \forall i = 1:n \cr \beta_{1},\dots,\beta_{n}~|~\mu,~K~\sim~&N_{p}\left(\mu,K\right) \cr \mu~\sim~&N_{p}\left(0,\sigma_{\mu}I_{p}\right) \cr \tau_{\epsilon} ~\sim~& Gamma\left(a,b\right) \cr K~|~ G ~\sim~& GWish\left(d,D\right) \cr G ~~& fixed \end{eqnarray*}$$}{\begin{eqnarray*}Y_{i}~|~\beta_{i},~\tau_{\epsilon} &~\sim~&N_{r}\left(\Phi\beta_{i},\tau_{\epsilon}I_{r}\right), &\forall i &= 1:n \cr \beta_{1},\dots,\beta_{n}~|~\mu,~K&~\sim~&N_{p}\left(\mu,K\right) \cr \mu&~\sim~&N_{p}\left(0,\sigma_{\mu}I_{p}\right) \cr \tau_{\epsilon} &~\sim~& Gamma\left(a,b\right) \cr K~|~ G ~&\sim~& GWish\left(d,D\right) \cr G ~&~ fixed \end{eqnarray*}}{\begin{eqnarray*}Y_{i}~|~\beta_{i},~\tau_{\epsilon} &~\sim~&N_{r}\left(\Phi\beta_{i},\tau_{\epsilon}I_{r}\right), &\forall i &= 1:n \cr \beta_{1},\dots,\beta_{n}~|~\mu,~K&~\sim~&N_{p}\left(\mu,K\right) \cr \mu&~\sim~&N_{p}\left(0,\sigma_{\mu}I_{p}\right) \cr \tau_{\epsilon} &~\sim~& Gamma\left(a,b\right) \cr K~|~ G ~&\sim~& GWish\left(d,D\right) \cr G ~&~ fixed \end{eqnarray*}}
}
