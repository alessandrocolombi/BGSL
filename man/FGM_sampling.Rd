% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BGSL_export.R
\name{FGM_sampling}
\alias{FGM_sampling}
\title{Functional Graphical model for smoothing}
\usage{
FGM_sampling(
  p,
  data,
  niter = 1e+05,
  burnin = niter/2,
  thin = 1,
  thinG = 1,
  Param = NULL,
  HyParam = NULL,
  Init = NULL,
  file_name = "FGMresults",
  form = "Complete",
  prior = "Uniform",
  algo = "RJ",
  groups = NULL,
  n_groups = 0,
  print_info = TRUE,
  seed = 0
)
}
\arguments{
\item{p}{integer, the number of basis functions. It also represents the dimension of the true underlying graph.}

\item{data}{matrix of dimension \mjseqn{n\_grid\_points \times n} containing the evaluation of \code{n} functional data over a grid of \code{n_grid_points} nodes.}

\item{niter}{the number of total iterations to be performed in the sampling. The number of saved iteration will be \mjseqn{(niter - burnin)/thin}.}

\item{burnin}{the number of discarded iterations.}

\item{thin}{the thining value, it means that only one out of \code{thin} itarations is saved.}

\item{thinG}{the thining value for graphical quantities, it means that Graph and Precision are only saved one every \code{thinG} itarations.}

\item{Param}{list containing parameters needed by the sampler. It has to follow the same notation of the one generated by \code{\link{sampler_parameters}} function.
It is indeed recommended to build it through that particular function. It is important to remember that \code{BaseMat} field is needed and cannot be defaulted. Use \code{\link{Generate_Basis}} to create it.
It has to be a matrix of dimension \mjseqn{n\_grid\_points \times p} containing the evalutation of \code{p} Bspline basis over a grid of \code{n_grid_points} nodes.}

\item{HyParam}{list containing hyperparameters needed by the sampler. It has to follow the same notation of the one generated by \code{\link{GM_hyperparameters}} function. It is indeed recommended to build it through that particular function.}

\item{Init}{list containig initial values for Markov chain. It has to follow the same notation of the one generated by \code{\link{GM_init}} function. It is indeed recommended to build it through that particular function.}

\item{file_name}{string, name of the file where the sampled values will be saved.}

\item{form}{string that may take as values only \code{"Complete"} of \code{"Block"} . It states if the algorithm has to run with \code{"Block"} or \code{"Complete"} graphs.}

\item{prior}{string with the desidered prior for the graph. Possibilities are \code{"Uniform"}, \code{"Bernoulli"} and for \code{"Block"} graphs only \code{"TruncatedBernoulli"} and \code{"TruncatedUniform"} are also available.}

\item{algo}{string with the desidered algorithm for sampling from a GGM. Possibilities are \code{"MH"}, \code{"RJ"} and \code{"DRJ"}.}

\item{groups}{a list representing the groups of the block form. Numerations starts from 0 and vertrices has to be contiguous from group to group,
i.e ((0,1,2),(3,4)) is fine but ((1,2,3), (4,5)) and ((1,3,5), (2,4)) are not. If \code{"NULL"}, \code{"n_groups"} are automatically generated. Not needed if form is set to \code{"Complete"}.}

\item{n_groups}{int, number of desired groups. Not used if form is \code{"Complete"} or if the groups are directly insered as group parameter.}

\item{print_info}{boolean, if true progress bar and execution time are displayed.}

\item{seed}{integer, seeding value. Set 0 for random seed.}
}
\value{
Two lists are returned, the first one, called \code{PosteriorMeans}, is composed of the posterior mean of those parameters related to the functional smoothing. The second one,
called \code{GraphAnalysis} is a summary of the sampled graphs. It is the same output of \code{\link{GGM_sampling}}, see its documentation for further details.
}
\description{
\loadmathjax This function implements an hybrid Gibbs Sampler strategy to draw samples from the posterior distribution of a Functional Graphical Model, reported below.
\mjtdeqn{$$\begin{eqnarray*}Y_{i}~|~\beta_{i},~\tau_{\epsilon} \sim~&N_{r}\left(\Phi\beta_{i},\tau_{\epsilon}I_{r}\right), &\forall i = 1:n \cr \beta_{1},\dots,\beta_{n}~|~\mu,~K\sim~&N_{p}\left(\mu,K\right) \cr \mu\sim~&N_{p}\left(0,\sigma_{\mu}I_{p}\right) \cr \tau_{\epsilon} \sim~& Gamma\left(a,b\right) \cr K~|~ G ~\sim~& GWish\left(d,D\right) \cr G ~\sim~&\pi\left(G\right) \end{eqnarray*}$$}{\begin{eqnarray*}Y_{i}~|~\beta_{i},~\tau_{\epsilon} &\sim~&N_{r}\left(\Phi\beta_{i},\tau_{\epsilon}I_{r}\right), &\forall i &= 1:n \cr \beta_{1},\dots,\beta_{n}~|~\mu,~K&\sim~&N_{p}\left(\mu,K\right) \cr \mu&\sim~&N_{p}\left(0,\sigma_{\mu}I_{p}\right) \cr \tau_{\epsilon} &\sim~& Gamma\left(a,b\right) \cr K~|~ G &\sim~& GWish\left(d,D\right) \cr G &\sim~&\pi\left(G\right) \end{eqnarray*}}{\begin{eqnarray*}Y_{i}~|~\beta_{i},~\tau_{\epsilon} &\sim~&N_{r}\left(\Phi\beta_{i},\tau_{\epsilon}I_{r}\right), &\forall i &= 1:n \cr \beta_{1},\dots,\beta_{n}~|~\mu,~K&\sim~&N_{p}\left(\mu,K\right) \cr \mu&\sim~&N_{p}\left(0,\sigma_{\mu}I_{p}\right) \cr \tau_{\epsilon} &\sim~& Gamma\left(a,b\right) \cr K~|~ G &\sim~& GWish\left(d,D\right) \cr G &\sim~&\pi\left(G\right) \end{eqnarray*}}
It has a double goal, performing a smoothing of the inserted noisy curves and estimating the graph which describes the relationship among the regression coefficients.
}
